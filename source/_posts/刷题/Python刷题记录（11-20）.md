---
title: Python刷题记录（11-20）
data: 2023-06-06 12:00:00
type: string
updated: 2023-06-06 12:00:00
tags: Python
categories: 刷题记录
---

题目来源PTA平台

[PAT (Basic Level) Practice （中文）](https://pintia.cn/problem-sets/994805260223102976)

------------------------------------------

## **1011 A+B 和 C**

给定区间 [−231,231] 内的 3 个整数 *A*、*B* 和 *C*，请判断 *A*+*B* 是否大于 *C*。

### 输入格式：

输入第 1 行给出正整数 *T* (≤10)，是测试用例的个数。随后给出 *T* 组测试用例，每组占一行，顺序给出 *A*、*B* 和 *C*。整数间以空格分隔。

### 输出格式：

对每组测试用例，在一行中输出 `Case #X: true` 如果 *A*+*B*>*C*，否则输出 `Case #X: false`，其中 `X` 是测试用例的编号（从 1 开始）。

### 输入样例：

```in
4
1 2 3
2 3 4
2147483647 0 2147483646
0 -2147483648 -2147483647
```

### 输出样例：

```out
Case #1: false
Case #2: true
Case #3: true
Case #4: false
```

### 思路：

> python不用担心数字过大的问题，随意计算

### 代码：

```python
T = int(input())
for i in range(1,T+1):
    a, b, c = map(float,input().split())
    if(a+b>c):
        print('Case #'+str(i)+': true')
    else:
        print('Case #'+str(i)+': false')
```



## **1012 数字分类**

给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：

- *A*1 = 能被 5 整除的数字中所有偶数的和；
- *A*2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 *n*1−*n*2+*n*3−*n*4⋯；
- *A*3 = 被 5 除后余 2 的数字的个数；
- *A*4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；
- *A*5 = 被 5 除后余 4 的数字中最大数字。

### 输入格式：

每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N*，随后给出 *N* 个不超过 1000 的待分类的正整数。数字间以空格分隔。

### 输出格式：

对给定的 *N* 个正整数，按题目要求计算 *A*1~*A*5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。

若其中某一类数字不存在，则在相应位置输出 `N`。

### 输入样例 1：

```in
13 1 2 3 4 5 6 7 8 9 10 20 16 18
```

### 输出样例 1：

```out
30 11 2 9.7 9
```

### 输入样例 2：

```in
8 1 2 4 5 6 7 9 16
```

### 输出样例 2：

```out
N 11 2 N 9
```

### 思路：

> 用列表存储跳过第一个对后面的数据进行处理
>
> 唯一注意点是A2的值可能为0

### 代码：

```python
n = [int(x) for x in input().split()]
a = [0, 0, 0, 0, 0]
a1_f = 0
a3_f = 0
for index, i in enumerate(n):
    if index == 0:
        continue
    if i % 10 == 0:
        a[0] += i
    if i % 5 == 1:
        a[1] += (-1)**a1_f*i
        a1_f += 1
    if i % 5 == 2:
        a[2] += 1
    if i % 5 == 3:
        a[3] += i
        a3_f += 1
    if i % 5 == 4 and i > a[4]:
        a[4] = i
for index, i in enumerate(a):
    if index != 0:
        print(' ', end='')
    if i != 0 and index != 1:
        if index == 3:
            print('%.1f' % (a[3]/a3_f), end='')
        else:
            print(i, end='')
    elif index == 1:
        if a1_f != 0 or i != 0:
            print(i, end='')
        else:
            print('N', end='')
    else:
        print('N', end='')
print()

```

## **1013 数素数**

令 *P**i* 表示第 *i* 个素数。现任给两个正整数 *M*≤*N*≤104，请输出 *P**M* 到 *P**N* 的所有素数。

### 输入格式：

输入在一行中给出 *M* 和 *N*，其间以空格分隔。

### 输出格式：

输出从 *P**M* 到 *P**N* 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。

### 输入样例：

```in
5 27
```

### 输出样例：

```out
11 13 17 19 23 29 31 37 41 43
47 53 59 61 67 71 73 79 83 89
97 101 103
```

### 思路：

> 如果是c++直接暴力判断是否为素数即可
>
> python这样做容易超时，采用埃拉托斯特尼筛法
>
> 唯一要注意的是测试点4应该是要求输出最后几位了，第10000个素数大概在105000以内

### 代码:

```python
n, m = map(int, input().split())
l = [1 for x in range(int(105000)+2)]
l[0] = l[1] = 0
for i in range(2, 105001):
    if l[i] == 1:
        for j in range(i*i, 105001, i):
            l[j] = 0
su = []
for i in range(2, 105001):
    if l[i] != 0:
        su.append(i)
count = 0
for i in range(n-1, m):
    print(su[i], end='')
    if i == m-1:
        print()
    elif (count+1) % 10 == 0:
        print()
    else:
        print(' ', end='')
    count += 1

```

## **1014 福尔摩斯的约会**

大侦探福尔摩斯接到一张奇怪的字条：`我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm`。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间`星期四 14:04`，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 `D`，代表星期四；第 2 对相同的字符是 `E` ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 `A` 到 `N` 表示）；后面两字符串第 1 对相同的英文字母 `s` 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。

### 输入格式：

输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。

### 输出格式：

在一行中输出约会的时间，格式为 `DAY HH:MM`，其中 `DAY` 是某星期的 3 字符缩写，即 `MON` 表示星期一，`TUE` 表示星期二，`WED` 表示星期三，`THU` 表示星期四，`FRI` 表示星期五，`SAT` 表示星期六，`SUN` 表示星期日。题目输入保证每个测试存在唯一解。

### 输入样例：

```in
3485djDkxh4hhGE 
2984akDfkkkkggEdsb 
s&hgsfdk 
d&Hyscvnm
```

### 输出样例：

```out
THU 14:04
```

### 思路：

> 进行字符判断，唯一需要注意的是星期的范围为A—G，小时的范围为A—N，

### 代码：

```python
a1 = input()
a2 = input()
b1 = input()
b2 = input()
result = []
sum = ["MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"]
for i in range(min(len(a1), len(a2))):
    if (a1[i] == a2[i]) and ('A' <= a1[i] <= 'G'):
        result.append(ord(a1[i])-ord('A')+1)
        break
for j in range(i+1, (min(len(a1), len(a2)))):
    if (a1[j] == a2[j]) and ('A' <= a1[j] <= 'N'):
        result.append(str(ord(a1[j])-ord('A')+10))
        break
    elif (a1[j] == a2[j]) and ('0' <= a1[j] <= '9'):
        result.append('0'+a1[j])
        break
for i in range(min(len(b1), len(b2))):
    if ('a' <= b1[i] <= 'z' or 'A' <= b1[i] <= 'Z') and (b1[i] == b2[i]):
        if i < 10:
            result.append('0'+str(i))
        else:
            result.append(str(i))
        break
print("%s %s:%s" % (sum[result[0]-1], result[1], result[2]))

```

## **1015 德才论**

宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”

现给出一批考生的德才分数，请根据司马光的理论给出录取排名。

### 输入格式：

输入第一行给出 3 个正整数，分别为：*N*（≤105），即考生总数；*L*（≥60），为录取最低分数线，即德分和才分均不低于 *L* 的考生才有资格被考虑录取；*H*（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 *H*，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 *L* 的考生也按总分排序，但排在第三类考生之后。

随后 *N* 行，每行给出一位考生的信息，包括：`准考证号 德分 才分`，其中`准考证号`为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。

### 输出格式：

输出第一行首先给出达到最低分数线的考生人数 *M*，随后 *M* 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。

### 输入样例：

```in
14 60 80
10000001 64 90
10000002 90 60
10000011 85 80
10000003 85 80
10000004 80 85
10000005 82 77
10000006 83 76
10000007 90 78
10000008 75 79
10000009 59 90
10000010 88 45
10000012 80 100
10000013 90 99
10000014 66 60
```

### 输出样例：

```out
12
10000013 90 99
10000012 80 100
10000003 85 80
10000011 85 80
10000004 80 85
10000007 90 78
10000006 83 76
10000005 82 77
10000002 90 60
10000014 66 60
10000008 75 79
10000001 64 90
```

### 思路：

> 按照常规思路进行输入，存储分组，最后进行排序
>
> 但是结果超时，搜索后发现绝大部分人都存在超时问题
>
> 后根据一位大佬的博客成功解决，但是没有看懂，以后有空再回顾
>
> 链接：https://www.pythonf.cn/read/58505
>
> 不过这题能使python的sort函数的使用有较大提高

### 代码：（超时）

```python
def fun(x):
    sum = -int(x[1])-int(x[2])
    a = -int(x[1])
    b = x[0]
    return sum, a, b


N, L, H = map(int, input().split())
student = []
s1 = []
s2 = []
s3 = []
s4 = []
for i in range(N):
    student.append(input().split())
    if int(student[i][1]) >= 80 and int(student[i][2]) >= 80:
        s1.append(student[i])
    elif int(student[i][1]) >= 80 and int(student[i][2]) >= 60 and int(student[i][2]) < 80:
        s2.append(student[i])
    elif int(student[i][1]) >= 60 and int(student[i][2]) >= 60 and int(student[i][1]) > int(student[i][2]):
        s3.append(student[i])
    elif int(student[i][1]) >= 60 and int(student[i][2]) >= 60:
        s4.append(student[i])
s1.sort(key=fun)
s2.sort(key=fun)
s3.sort(key=fun)
s4.sort(key=fun)
s = s1+s2+s3+s4
print(len(s))
for i in s:
    print(' '.join(i))
```

## **1016 部分A+B**

正整数 *A* 的“*D**A*（为 1 位整数）部分”定义为由 *A* 中所有 *D**A* 组成的新整数 *P**A*。例如：给定 *A*=3862767，*D**A*=6，则 *A* 的“6 部分”*P**A* 是 66，因为 *A* 中有 2 个 6。

现给定 *A*、*D**A*、*B*、*D**B*，请编写程序计算 *P**A*+*P**B*。

### 输入格式：

输入在一行中依次给出 *A*、*D**A*、*B*、*D**B*，中间以空格分隔，其中 0<*A*,*B*<1010。

### 输出格式：

在一行中输出 *P**A*+*P**B* 的值。

### 输入样例 1：

```in
3862767 6 13530293 3
```

### 输出样例 1：

```out
399
```

### 输入样例 2：

```in
3862767 1 13530293 8
```

### 输出样例 2：

```out
0
```

### 思路：

> 按字符串读取，然后进行字符匹配，最后计算P的值
>
> 要注意无匹配的时候P=0

### 代码：

```python
def fun(a, b):
    num = 0
    for i in a:
        if i == b:
            num += 1
    return num


def com_p(n, m):
    ans = m
    if n == 0:
        return 0
    for i in range(n-1):
        ans = ans*10+m
    return ans


l = [x for x in input().split()]
a = fun(l[0], l[1])
b = fun(l[2], l[3])
print(com_p(a, int(l[1]))+com_p(b, int(l[3])))

```

## **1017 A除以B**

本题要求计算 *A*/*B*，其中 *A* 是不超过 1000 位的正整数，*B* 是 1 位正整数。你需要输出商数 *Q* 和余数 *R*，使得 *A*=*B*×*Q*+*R* 成立。

### 输入格式：

输入在一行中依次给出 *A* 和 *B*，中间以 1 空格分隔。

### 输出格式：

在一行中依次输出 *Q* 和 *R*，中间以 1 空格分隔。

### 输入样例：

```in
123456789050987654321 7
```

### 输出样例：

```out
17636684150141093474 3
```

### 思路：

> 没有思路了暴力算就完事， python yyds

### 代码：

```python
a, b = map(int, input().split())
print(a//b, a % b)

```

## **1018 锤子剪刀布**

大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：

<img src='https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg'>

现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。

### 输入格式：

输入第 1 行给出正整数 *N*（≤105），即双方交锋的次数。随后 *N* 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。`C` 代表“锤子”、`J` 代表“剪刀”、`B` 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。

### 输出格式：

输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。

### 输入样例：

```in
10
C J
J B
C B
B B
B C
C C
C B
J B
B C
J J
```

### 输出样例：

```out
5 3 2
2 3 5
B B
```

### 思路：

> 题目并不难，就是比较麻烦，按照要求进行操作就行
>
> 但是在测试点5发生了超时问题，盲猜使因为测试数据过大的原因，通过以为大佬写德才论的思路得到启发，使用sys中的输入输出库完美解决

### 代码：

```python
import sys


def fun(a, b, c):
    if max(a, b, c) == a:
        return 'B'
    elif max(a, b, c) == b:
        return 'C'
    else:
        return 'J'


n = int(sys.stdin.readline())
l = [[x for x in sys.stdin.readline().split()]for i in range(n)]
a = [0, 0, 0, 0, 0, 0]  # 胜负平布锤剪
b = [0, 0, 0, 0, 0, 0]

for i in l:
    if i[0] == 'B':
        if i[1] == 'C':
            a[0] += 1
            a[3] += 1
            b[1] += 1
        elif i[1] == 'J':
            a[1] += 1
            b[0] += 1
            b[5] += 1
        else:
            a[2] += 1
            b[2] += 1
    elif i[0] == 'C':
        if i[1] == 'B':
            a[1] += 1
            b[0] += 1
            b[3] += 1
        elif i[1] == 'C':
            a[2] += 1
            b[2] += 1
        else:
            a[0] += 1
            a[4] += 1
            b[1] += 1
    else:
        if i[1] == 'B':
            a[0] += 1
            a[5] += 1
            b[1] += 1
        elif i[1] == 'C':
            a[1] += 1
            b[0] += 1
            b[4] += 1
        else:
            a[2] += 1
            b[2] += 1
sys.stdout.write('%d %d %d\n' % (a[0], a[2], a[1]))
sys.stdout.write('%d %d %d\n' % (b[0], b[2], b[1]))
sys.stdout.write('%c %c\n' % (fun(a[3], a[4], a[5]), fun(b[3], b[4], b[5])))

```

## **1019 数字黑洞**

给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 `6174`，这个神奇的数字也叫 Kaprekar 常数。

例如，我们从`6767`开始，将得到

```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
```

现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。

### 输入格式：

输入给出一个 (0,104) 区间内的正整数 *N*。

### 输出格式：

如果 *N* 的 4 位数字全相等，则在一行内输出 `N - N = 0000`；否则将计算的每一步在一行内输出，直到 `6174` 作为差出现，输出格式见样例。注意每个数字按 `4` 位数格式输出。

### 输入样例 1：

```in
6767
```

### 输出样例 1：

```out
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
```

### 输入样例 2：

```in
2222
```

### 输出样例 2：

```out
2222 - 2222 = 0000
```

### 思路：

> 利用rjust函数补齐并存储在list中，对其进行排序后转换成int型进行计算，要注意输入6174也要参与一次计算

### 代码：

```python
n = list(input().rjust(4, '0'))
if n[0] == n[1] == n[2] == n[3]:
    print(''.join(n)+' - ' + ''.join(n)+' = 0000')
else:
    while True:
        a = int(''.join(sorted(n, reverse=True)))
        b = int(''.join(sorted(n)))
        ans = a-b
        if ans == 6174:
            print('%04d - %04d = 6174' % (a, b))
            break
        else:
            print('%04d - %04d = %04d' % (a, b, ans))
        n = list(str(ans).rjust(4, '0'))

```

## **1020 月饼**

月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。

注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。

### 输入格式：

每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N* 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 *D* 表示市场最大需求量。随后一行给出 *N* 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 *N* 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。

### 输出格式：

对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。

### 输入样例：

```in
3 20
18 15 10
75 72 45
```

### 输出样例：

```out
94.50
```

### 思路：

> 非常常规的一道贪心算法题，唯一需要注意的是月饼库存和售价是正数而非整数，不考虑会造成测试点2非零返回

### 代码：

```python
n, m = map(int, input().split())
l = [float(x) for x in input().split()]
price = [float(x) for x in input().split()]
ave = [[l[i], price[i], price[i]/l[i]] for i in range(n)]
ave.sort(key=lambda x: -x[2])
ans = 0
for i in ave:
    if m > i[0]:
        m -= i[0]
        ans += i[1]
    else:
        ans += m*i[2]
        break
print('%.2f' % ans)

```

