---
title: Python刷题记录（31-40）
data: 2023-06-06 12:00:00
type: string
updated: 2023-06-06 12:00:00
tags: Python
categories: 刷题记录
---

题目来源PTA平台

[PAT (Basic Level) Practice （中文）](https://pintia.cn/problem-sets/994805260223102976)

-----------

## **1031 查验身份证** 

一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：

首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值`Z`；最后按照以下关系对应`Z`值与校验码`M`的值：

```
Z：0 1 2 3 4 5 6 7 8 9 10
M：1 0 X 9 8 7 6 5 4 3 2
```

现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。

### 输入格式：

输入第一行给出正整数*N*（≤100）是输入的身份证号码的个数。随后*N*行，每行给出1个18位身份证号码。

### 输出格式：

按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出`All passed`。

### 输入样例1：

```in
4
320124198808240056
12010X198901011234
110108196711301866
37070419881216001X
```

### 输出样例1：

```out
12010X198901011234
110108196711301866
37070419881216001X
```

### 输入样例2：

```
2
320124198808240056
110108196711301862
```

### 输出样例2：

```
All passed
```

**鸣谢阜阳师范学院范建中老师补充数据**

**鸣谢浙江工业大学之江学院石洗凡老师纠正数据**

### 思路：

> 判断前17位是否含有字母，含有则直接输出
>
> 按权进行求和并进行校验，当没有错误是输出`All passed`

### 代码：

```python
M = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2']
vlaue = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]


def fun(t):
    for i in t[:17]:
        if i.isalpha():
            print(t)
            return False
    sum_num = 0
    for i, j in enumerate(t[:17]):
        sum_num += int(j)*vlaue[i]
    return sum_num


n = int(input())
f = 0
for i in range(n):
    t = input().upper()
    if len(t) != 18:
        print(t)
        continue
    ans = fun(t)
    if ans == False:
        f += 1
        continue
    else:
        if M[ans % 11] != t[17]:
            f += 1
            print(t)
if f == 0:
    print('All passed')

```

## **1032 挖掘机技术哪家强** 

为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。

### 输入格式：

输入在第 1 行给出不超过 105 的正整数 *N*，即参赛人数。随后 *N* 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。

### 输出格式：

在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。

### 输入样例：

```in
6
3 65
2 80
1 100
2 70
3 40
3 0
```

### 输出样例：

```out
2 150
```

### 思路：

> 根据输入样例动态开辟列表空间，将每个分数加到学校编号对应的列表中
>
> 使用max函数寻找最大值，index函数找编号
>
> 使用sys库中的输入避免测试点3超时

### 代码：

```python
import sys

n = int(input())
data = [0]*(n+1)
for i in range(n):
    a, b = map(int, sys.stdin.readline().split())
    data[a] += b
t = max(data)
print(data.index(t), t)

```

## **1033 旧键盘打字**

旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？

### 输入格式：

输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [`a`-`z`, `A`-`Z`]、数字 `0`-`9`、以及下划线 `_`（代表空格）、`,`、`.`、`-`、`+`（代表上档键）。题目保证第 2 行输入的文字串非空。

注意：如果上档键坏掉了，那么大写的英文字母无法被打出。

### 输出格式：

在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。

### 输入样例：

```in
7+IE.
7_This_is_a_test.
```

### 输出样例：

```out
_hs_s_a_tst
```

### 思路：

> 输入后首先判断上档键是否损坏，注：这里的上档键只有+
>
> 然后遍历第二个字符串，利用find函数查找是否包含在第一个函数内，找不到就输出，如果上档键损坏，在去除其中的大写

### 代码：

```python
str1 = input()
str2 = input()
flag_upper = 0
if str1.find('+') != -1:
    flag_upper = 1
for i in str2:
    if flag_upper == 1:
        if str1.find(i.upper()) == -1 and i.isupper() == False:
            print(i, end='')
    else:
        if str1.find(i.upper()) == -1:
            print(i, end='')
print()
```

## **1034 有理数四则运算** 

本题要求编写程序，计算 2 个有理数的和、差、积、商。

### 输入格式：

输入在一行中按照 `a1/b1 a2/b2` 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。

### 输出格式：

分别在 4 行中按照 `有理数1 运算符 有理数2 = 结果` 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 `k a/b`，其中 `k` 是整数部分，`a/b` 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 `Inf`。题目保证正确的输出中没有超过整型范围的整数。

### 输入样例 1：

```in
2/3 -4/2
```

### 输出样例 1：

```out
2/3 + (-2) = (-1 1/3)
2/3 - (-2) = 2 2/3
2/3 * (-2) = (-1 1/3)
2/3 / (-2) = (-1/3)
```

### 输入样例 2：

```in
5/3 0/6
```

### 输出样例 2：

```out
1 2/3 + 0 = 1 2/3
1 2/3 - 0 = 1 2/3
1 2/3 * 0 = 0
1 2/3 / 0 = Inf
```

### 思路：

> 这题细节很多，参考了下柳婼大佬的思路
>
> 首先编写一个gcd求最大公因数，以便进行化解
>
> 编写一个trans函数对有理数进行处理，首先分母为零输出‘Inf’，分子为0输出0
>
> 再判断n*m<0，小于输出'(-'
>
> 然后计算是否含有整数部分
>
> 最后进行化简，如果是负数再输出')'

## 代码：

```python
def trans(n, m):
    f = 0
    s = ''
    if n*m == 0:
        if n == 0:
            s += '0'
        else:
            s += 'Inf'
        return s
    elif n*m < 0:
        f = 1
        n = abs(n)
        m = abs(m)
        s += '(-'
    x = n//m
    if x != 0:
        s += str(x)
        n = n-x*m
    if n % m == 0:
        if f == 1:
            s += ')'
        return s
    if x != 0:
        s += ' '
    t = gcd(n, m)
    s += str('%d/%d' % (n//t, m//t))
    if f == 1:
        s += ')'
    return s


def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)


a, b, c, d = map(int, input().replace('/', ' ').split())
print('{} + {} = {}'.format(trans(a, b), trans(c, d), trans(a*d+b*c, b*d)))
print('{} - {} = {}'.format(trans(a, b), trans(c, d), trans(a*d-b*c, b*d)))
print('{} * {} = {}'.format(trans(a, b), trans(c, d), trans(a*c, b*d)))
print('{} / {} = {}'.format(trans(a, b), trans(c, d), trans(a*d, b*c)))
```

## **1035 插入与归并**

根据维基百科的定义：

**插入排序**是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。

**归并排序**进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。

现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？

### 输入格式：

输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。

### 输出格式：

首先在第 1 行中输出`Insertion Sort`表示插入排序、或`Merge Sort`表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。

### 输入样例 1：

```in
10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
```

### 输出样例 1：

```out
Insertion Sort
1 2 3 5 7 8 9 4 6 0
```

### 输入样例 2：

```in
10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6
```

### 输出样例 2：

```out
Merge Sort
1 2 3 8 4 5 7 9 0 6
```

### 思路：

> 这题思路并不复杂，但是我一直想如何不要那么复杂的去实现，再参考（搬运）了一位大佬提交到github上的代码，找到了我所想要的
>
> 对于插入排序只需要判断前面升序序列后的部分是与原排序相同，相同就输出Insertion Sort并执行一轮
>
> 排除上面的情况后就是Merge Sort，从cnt=2开始进行排序，直到列表发生变化，输出即可（每次cnt*=2）

### 代码：

```python
def check(lst1, lst2):
    flag = 0
    for i in range(len(lst2)-1):
        if lst2[i] > lst2[i+1]:
            flag = i + 1
            break
    if lst1[flag:] == lst2[flag:]:  # 插入排序
        result = sorted(lst1[:flag+1])+lst2[flag+1:]  # 再迭代一轮的结果
        return True, result
    else:  # 归并排序
        cnt = 2  # 归并的数量
        result = lst2
        while result == lst2:  # 不断归并排序直到顺序发送变化
            sub_lst = [sorted(lst2[i:i+cnt])
                       for i in range(0, len(lst2), cnt)]  # 生成二维列表
            result = [num for sub in sub_lst for num in sub]  # 将二维列表转为1维
            cnt *= 2
        return False, result


num = int(input())
lst1 = [int(i) for i in input().split()]
lst2 = [int(i) for i in input().split()]
flag, next_list = check(lst1, lst2)
if flag:
    print("Insertion Sort")
else:
    print("Merge Sort")
print(" ".join([str(i) for i in next_list]))

```

## **1036 跟奥巴马一起编程**

美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！

### 输入格式：

输入在一行中给出正方形边长 *N*（3≤*N*≤20）和组成正方形边的某种字符 C，间隔一个空格。

### 输出格式：

输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。

### 输入样例：

```in
10 a
```

### 输出样例：

```out
aaaaaaaaaa
a        a
a        a
a        a
aaaaaaaaaa
```

### 思路：

> 唯一要点向上取整

### 代码：

```python
lst = [x for x in input().split()]
n = int(lst[0])
print(lst[1]*n)
for i in range(n//2-2+n % 2):
    print(lst[1]+' '*(n-2)+lst[1])
print(lst[1]*n)

```

## **1037 在霍格沃茨找零钱**

如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 *P* 和他实付的钱 *A*，你的任务是写一个程序来计算他应该被找的零钱。

### 输入格式：

输入在 1 行中分别给出 *P* 和 *A*，格式为 `Galleon.Sickle.Knut`，其间用 1 个空格分隔。这里 `Galleon` 是 [0, 107] 区间内的整数，`Sickle` 是 [0, 17) 区间内的整数，`Knut` 是 [0, 29) 区间内的整数。

### 输出格式：

在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。

### 输入样例 1：

```in
10.16.27 14.1.28
```

### 输出样例 1：

```out
3.2.1
```

### 输入样例 2：

```in
14.1.28 10.16.27
```

### 输出样例 2：

```out
-3.2.1
```

### 思路：

> 首先判断p和a的大小，p比a大就交换位置并输出‘-’
>
> 然后利用手算减法的思路一步步计算，注意借位

### 代码：

```python
def fun(p, a):
    if p[2] <= a[2]:
        k = a[2]-p[2]
    else:
        k = a[2]+29-p[2]
        a[1] -= 1
    if p[1] <= a[1]:
        s = a[1]-p[1]
    else:
        s = a[1]+17-p[1]
        a[0] -= 1
    g = a[0]-p[0]
    print('%d.%d.%d' % (g, s, k))


p, a = [x for x in input().split()]
p = [int(x) for x in p.split('.')]
a = [int(x) for x in a.split('.')]
if p[0] > a[0] or (p[0] == a[0] and p[1] > a[1]) or (p[0] == a[0] and p[1] == a[1] and p[2] > a[2]):
    print('-', end='')
    fun(a, p)
else:
    fun(p, a)

```

## **1038 统计同成绩学生**

本题要求读入 *N* 名学生的成绩，将获得某一给定分数的学生人数输出。

### 输入格式：

输入在第 1 行给出不超过 105 的正整数 *N*，即学生总人数。随后一行给出 *N* 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 *K*（不超过 *N* 的正整数），随后是 *K* 个分数，中间以空格分隔。

### 输出格式：

在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。

### 输入样例：

```in
10
60 75 90 55 75 99 82 90 75 50
3 75 90 88
```

### 输出样例：

```out
3 2 0
```

### 思路：

> 原本简单的想用count函数解决结果测试点3超时
>
> 无奈转为使用数组统计

### 代码：

```python
import sys

n = int(input())
lst = [int(x) for x in sys.stdin.readline().split()]
findlist = [int(x) for x in sys.stdin.readline().split()]
a = [0]*101
for i in lst:
    a[i] += 1
s = []
for i in findlist[1:]:
    s.append(str(a[i]))
print(' '.join(s))

```

## **1039 到底买不买**

小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。

为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。

<img src="https://images.ptausercontent.com/b7e2ffa6-8819-436d-ad79-a41263abe914.jpg">

图 1

### 输入格式：

每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。

### 输出格式：

如果可以买，则在一行中输出 `Yes` 以及有多少多余的珠子；如果不可以买，则在一行中输出 `No` 以及缺了多少珠子。其间以 1 个空格分隔。

### 输入样例 1：

```in
ppRYYGrrYBR2258
YrR8RrY
```

### 输出样例 1：

```out
Yes 8
```

### 输入样例 2：

```in
ppRYYGrrYB225
YrR8RrY
```

### 输出样例 2：

```out
No 2
```

### 思路：

> 使用数组记录每种珠子各有几颗
>
> 缺珠子时记录数量，最后输出No和数量
>
> 不缺时，输出Yes和两个字符串长度之差

### 代码：

```python
def fun(s):
    a = [0]*62
    for i in s:
        if i.isdigit():
            a[ord(i)-48] += 1
        elif i.islower():
            a[ord(i)-87] += 1
        else:
            a[ord(i)-29] += 1
    return a


str1 = input()
str2 = input()
a = fun(str1)
b = fun(str2)
count = 0
for i in range(62):
    if b[i] != 0 and b[i] > a[i]:
        count += b[i]-a[i]
if count > 0:
    print('No '+str(count))
else:
    print('Yes '+str(len(str1)-len(str2)))

```

## **1040 有几个PAT** 

字符串 `APPAPT` 中包含了两个单词 `PAT`，其中第一个 `PAT` 是第 2 位(`P`)，第 4 位(`A`)，第 6 位(`T`)；第二个 `PAT` 是第 3 位(`P`)，第 4 位(`A`)，第 6 位(`T`)。

现给定字符串，问一共可以形成多少个 `PAT`？

### 输入格式：

输入只有一行，包含一个字符串，长度不超过105，只包含 `P`、`A`、`T` 三种字母。

### 输出格式：

在一行中输出给定字符串中包含多少个 `PAT`。由于结果可能比较大，只输出对 1000000007 取余数的结果。

### 输入样例：

```in
APPAPT
```

### 输出样例：

```out
2
```

### 思路：

> 太菜以至于没有思路看，借用柳婼大佬的思路
>
> 先计算t的个数，然后遍历，碰到T就countt--，碰到P就countp++，碰到A就count+=countt*countp，记得对 1000000007 取余数

### 代码：

```python
n = input()
conutt = n.count('T')
countp = 0
countsum = 0
for i in n:
    if i == 'P':
        countp += 1
    elif i == 'T':
        conutt -= 1
    else:
        countsum = (countsum+conutt*countp) % 1000000007
print(countsum)

```

